学习笔记

1.动态规划定义：分治+最优子结构
（1）找重复子问题+数学归纳法（其实就是递推）
（2）将一个复杂的问题 转换为一个简单的子问题 并且要求解最优解（不必存放中间结果 中途可以淘汰次优解）
（3）解题步骤
	a）分治：找到子问题
	b）状态数组定义：
	c）DP方程：
	讲的比较好的动态规划：
	https://leetcode-cn.com/problems/coin-change/solution/dong-tai-gui-hua-tao-lu-xiang-jie-by-wei-lai-bu-ke/
2.路径之和
（1）无障碍物
	dp方程：
	dp[i][j]=dp[i][j+1] + dp[i+1][j]
	含义：任何一个节点到终点都有两种走法 向右 向下
	特殊处理：终点所在节点的那一行和一列 所有的dp[i][j]都为1 因为边界的地方都只有一个方向（要么向下 要么下右）才能到达终点

（2）有障碍物
	第一、dp方程与（1）一样 只是在处理每一步时 都需要判断当前位置是否有障碍物 如果有的话dp[i][j]设置为0即可
	第二、边界的处理：
		1）终点所在位置的一行：dp[i][j] = dp[i][j+1]
		2）终点所在位置的一列：dp[i][j] = dp[i+1][j]

3.最大/长公共子序列
* dp方程：
 * dp[i][j]=
 * （1）text1.charAt(i) == text2.charAt(j)时
 * dp[i][j]=dp[i-1][j-1] + 1
 * (2)text1.charAt(i) != text2.charAt(j)时
 * dp[i][j]=Max(dp[i-1][j],dp[i][j-1])
细节：1）边界的处理 2）dp[][]多一行一列 第0列和第0行用作哨兵

4.三角形最短路径之和
实质：从一个只有一半的二维矩阵中的（0，0）节点出发 到达最后一层的最短路径之和
 * 每次移动的时候 只能向下或向右移动一个格子（即：一步）
 * dp方程：
 * dp[i][j]=Min(dp[i+1][j],dp[i+1][j+1]) + nums[i][j]
 * 即：当前位置（i,j)到达最后一层的最短路径就为它的下一层中的两个相邻节点到达底层的最短路径中的较小者再加上当前位置上的值

5.最大子序列和
（1）分治：将第i个位置的最大子序列和问题转换为求第i-1个位置的最大子序列和问题
（2）状态数组定义：dp[i]表示在i位置所形成的最大子序列和的值
（3）dp方程：
	a)dp[i]=Max(nums[i],dp[i-1] + nums[i])
	b)含义：最大子序列和=当前位置元素本身最大，或者包含之前+本身之后最大
（4）dp方程只是记录了在每个位置上的最大子序列和 还需要记住当前最大的子序列和 所以还额外需要一个max变量 用于存放当前最大和 用以返回
