#1.主题：Jdk 1.8 Queue和PriorityQueue源码分析

1.Queue
（1）Queue只是一个接口
接口中的方法包含：
	group1-入队:队尾插入新元素 add(); offer(); 二者的区别：add()要么返回true 要么throws Excception; offer()：返回true或false 或throws Exception
	group2-出队:删除队头位置的元素 remove(); poll();二者的区别：前者在队列为空时throws NoSuchElementException 后者返回null
	group3-查看队顶元素:查看队头元素 但不执行删除操作 element(); peek(); 二者的区别：前者在队列为时throws NoSuchElementException 后者返回null
	总结：队尾入 队头出 要保证先进先出的特性不变；另外对于以上三组方法的调用要关注具体的业务场景下是根据有返回值来判断操作是否执行成功 还是根据是否抛出异常判断成功与否 其它无本质差别

2.PirorityQueue
（1）优先队列的使用
	1）基本数据类型:例如：Integer 可直接按数值的大小进行排序 而不必自行写比较算法
	2）自定义数据类型：需要实现Comparable接口 并重写compareTo()方法

（2）优先队列内部实现原理
   1)数据存放使用的是一个一维数组
   2)但此数组是一个小顶堆的二叉小顶堆，即：堆顶元素是最小的元素
   3)入队操作：先将待插入的元素放到当前队列队尾 再依次向上进行调整 并找到一个合适的插入位置
   4)出队操作：先将堆中的最后一个节点 放到根节点 然后自上而上进行调整 直到找到一个合适的插入位置
   
（3）基本操作：相当于是对Queue接口的实现之后具体的含义
	add(),offer():使用同一套代码实现 添加一个元素 先将此元素插入到队末尾 再依次自下而上进行调整
	remove(),poll():堆顶元素出队
	element(),peek():查看队顶元素 也就是堆顶元素（但不会出队）

（4）引申：堆排序的过程及建堆、插入元素、删除元素会如何对一个堆进行操作？假设此堆就用一个一维数组来实现？？？
	参考文档：https://www.cnblogs.com/chengxiao/p/6129630.html
	堆排序时间复杂度：O(nlogn)
	选择排序、不稳定的排序
	根据排序升序还是降序的要求 建不同的堆 升序：建立大顶堆 降序：建立小顶堆
	排序过程：以升序排序为例（建大顶堆）
	1）从最后一个非叶子节点进行自下而上的调整，使得每个经过的节点都满足大顶堆的定义（注：如果当前的调整破坏了以当前节点为根的堆 则需要向下调整）
	2）一直调整到根节点：删除根节点 并将根节点与最后一个节点交换 得到当前最大的元素
	3）从次非叶子节点开始重复1）的操作，得到次大的节点，与节点倒数第二个数进行交换 
	
	其它：
	1）一维数组存放数据
	2）对堆中的元素 按层进行编号，则有：i:父节点 2*i + 1-->左子树根节点 2*i+2-->右子树根节点
	3）插入一个节点
	4）删除一个节点

3.参考文档
https://blog.csdn.net/u012551350/article/details/98871314

